The Zprime2muAnalysis package
-----------------------------

Authors: Robert Cousins
         Jason Mumford
         Jordan Tucker
         Slava Valuev
         (UCLA)

Electron Extension Contributor: Jeremy Werner (Princeton)

Zprime2muAnalysis consists of several analysis modules intended for
studying high-mass resonances.

Zprime2muAnalysis:   fills vectors of leptons, constructs dileptons,
                     calculates invariant mass and other quantities. This is
                     the base class for the other modules, so its code is
                     called in each of them.

Zprime2muResolution: calculates resolutions (mass, phi, eta, etc.) of
                     the lepton fits at different levels of reconstruction
                     and plots them.

Zprime2muAsymmetry:  performs 6D unbinned maximum-likelihood fits to measure
                     the forward-backward asymmetry (A_{FB}) for Drell-Yan
                     and Z' events, for both generated and reconstructed
                     leptons (see CMS NOTE 2005/022).

Zprime2muMassReach:  performs unbinned maximum-likelihood fits to measure
                     signal and background contribution to the dilepton
                     spectrum and calculates the discovery potential for a
                     given integrated luminosity (see CMS NOTE 2006/062).

As mentioned above, Zprime2muAnalysis is not intended to be run
separately, except for debugging purposes. In this case it will dump
to the appropriate MessageLogger destination various messages
concerning the selection of leptons (either generated, or at various
levels of reconstruction) and the assembling of dileptons.

The .cfg files in the test/ subdirectory illustrate usage of these
modules; default parameters for each module are specified in the .cfi
and .cff files in the data/ subdirectory. As in the .cfg files, in
general these modules take as input EDM ROOT files with
fully-reconstructed gamma*/Z0/Z'/G/G* --> l- l+ events (with
l=e,mu). Official sample files for Z' events in 2_1_X are being
created; in the meantime one may use private samples or work with
DY/other events found via DBS: https://cmsweb.cern.ch/dbs_discovery/ .

At the time this documentation was updated, the package has been 
tested to work with version 2_1_12 of CMSSW. The tag V00-03-01 should
be used. (However, there is an experts' branch targeting CMSSW_1_6_12
which can be checked out; see the section "CMSSW 1_6_12".) We have
abandoned our private BaseMuon/Muon/DiMuon classes in favor of using
directly the standard AnalysisTools classes (reco::Candidate and all
its derived classes, including those of the PAT). Also, the package
has been modified for greater modularity with respect to V00-01-03,
with most of the functionality that was in Zprime2muAnalysis being
pieced out into modules in the plugins directory, and the inheritance
structure of the analysis modules being changed. See the below
discussion on Zprime2muAnalysis v. Zprime2muRecLevelAnalysis.

While much of the base class Zprime2muAnalysis along with its provided
interface for accessing the (di)lepton four-vectors and other data has
changed from V00-00-* series, the bulk of the logic in the derived
classes has remained the same, as has the physics. The rest of this
document is devoted to details of how the standard AnalysisTools
classes are used, how the data can be accessed by customers of the
base class, Zprime2muAnalysis, and how the three included analysis
modules, Resolution, Asymmetry, and MassReach, can be configured and
run.


Philosophy
----------

There are two general classes of analyses envisioned for use with this
package:

- "plain" analysis, which just wants simple access to the "best"
  (di)leptons;
- or "rec level" analysis, which has multiple collections of leptons
  and dileptons at various levels of reconstruction.

The base class Zprime2muAnalysis handles the former, pulling out the
generator-level and reconstructed dileptons for use by any derived
classes. Using a helper class, it handles extracting the trigger
decision as well.

The class Zprime2muRecLevelAnalysis inherits from
Zprime2muAnalysis. In it, leptons are stored at different levels of
reconstruction ("rec levels"), of which there are currently nine
defined. These were originally for dealing with different levels of
muon reconstruction:

  - generated muons (GEN),
  - Level-1, Level-2, and Level-3 of the muon trigger system (L1, L2, L3),
  - globally-reconstructed muons (GMR),
  - tracker-only (TK),
  - tracker-plus-first-muon-station (FMS),
  - muons reconstructed "pickily" (PMR),
  - and "best" muons, chosen from the previous four options on a
    muon-by-muon basis using some track goodness-of-fit criteria (OPT).

TK, FMS, and PMR are designed to deal with showering TeV muons, for
which GMR is not the best choice for reconstruction.

When running in electron mode, these three rec levels are no longer
appropriate, and are simply left empty. OPT in electron mode is filled
with the output of the HEEPSelector written by D.L. Evans (which must be
checked out separately; see the example at the end of this document).

data/Zprime2muAnalysisCommon_cff.py organizes the various input
collections of leptons, first running any AnalysisTools modules to
produce, select, merge, or sort the collections needed for the various
levels of reconstruction of both muons and electrons. The VInputTags
muInputs and elInputs then match input collections to the right rec
levels (for electrons, skipping rec levels lTK through lPMR).

The input collections thus defined (whether CandidateCollections,
MuonCollections, or any other vector of objects deriving from
reco::Candidate) are accessed in the code using edm::View. In the
classes, we store references to leptons in vectors of
reco::CandidateBaseRef objects, and collections of dileptons as vectors of
reco::CompositeCandidate objects:

  // excerpt from Zprime2muRecLevelAnalysis.h

  // The lepton collections, stored as CandidateBaseRefs.
  reco::CandidateBaseRefVector allLeptons[MAX_LEVELS];

  // The dilepton collections, stored as CompositeCandidates.
  reco::CompositeCandidateCollection allDileptons[MAX_LEVELS];

with one vector for each rec level. (CandidateBaseRefs were chosen
over CandidateRefs for technical reasons documented in code comments.)

Matching between rec levels (especially to MC truth) and matching
closest photons is done using the Analysis Tools module
TrivialDeltaRMatcher. Since we moved to Python configuration files,
running a loop over all pairs of rec levels in the configuration file
is just as easy as doing so in the code.

We have a custom module to match all offline leptons to other offline
leptons by "seed". By-seed matching finds pairs of
offline-reconstructed leptons that share the same seed track in the
muon system, which is useful when trying to pick the "best" muon,
since we need to know which muon in TK corresponds to which in PMR,
etc.

Dileptons are constructed as reco::CompositeCandidates, pruned of
overlap (if two dileptons share a lepton, preference is given to the
dilepton of higher invariant mass), and stored in
reco::CandidateCollections (one collection at each rec level). For
offline-reconstructed muons (GMR level and higher), an attempt is made
to recover energy loss from bremmed photons by adding in the
four-vectors of each of the leptons' closest photons, found in the
matching step above.

Trigger information is also stored: for muons we look at the trigger
paths used by the 2007 high-mass dimuon analysis (the result of which
was presented in CMS AN 2007/038), and for electrons we look at the
trigger paths used by the HEEP group. For muons, the "official"
results are compared to a homemade implementation for trigger studies.

All of the above dumps helpful debugging information to the
MessageLogger, depending on the level of the verbosity flag; see its
discussion below.


Accessing this data in code
---------------------------

The main documentation for the code exists in the header
files. Examples of accessing simple things are in the method
Zprime2muRecLevelAnalysis::dumpLepton() (which besides dumping
debugging info, was written for documentation purposes), and in the
existing analysis classes, Asymmetry, Resolution, and MassReach.


Configuring Zprime2muAnalysis
-----------------------------

There are quite a few flags and parameters of interest in the various
modules, which can be set either editing data/*_cff.y or (preferably)
in the user's config file using the replace syntax. E.g. when running
Zprime2muResolution, one might put the following line in the _cfg.py
file:

  process.Zprime2muResolution.verbosity = 2

There are some flags common to all modules Zprime2mu*, since they are
used by the base class Zprime2muAnalysis:

(Note: these next flags must be passed into the
 makeZprime2muAnalysisProcess() function instead of using the replace
 syntax above, since the loops in the Python config depend on
 them. See testZprime2muResolution_cfg.py for example use.)

    doingElectrons: whether to run on electron or muon collections
    (i.e. which collections are in allLeptons in the code). Default is
    False, so we run on muons.
    
    useGen/Sim/Reco: whether to expect information from GEN, SIM or
    RECO branches. (What to expect when useReco is set is modified by
    the usingAODOnly parameter below.)
    
    usingAODOnly: if True, do not expect to be able to get
    reconstruction-level objects that are not in AOD, such as rechits.

    useOtherMuonRecos: whether to expect the extra TeV muon
    reconstructors in the input files. Default is True, but if running
    on "official" files that do not have these extra collections
    (i.e. most likely every file that was not produced with the
    scripts in test/makeScripts of this package), this needs to be set
    False.

    useTrigger: whether to expect to be able to get trigger
    collections (i.e. those destined for L1-L3 rec levels) from the
    file.


Zprime2muResolution
-------------------

The user defines the mass range for the histograms to be produced, and
the number of bins.  The user inputs the ROOT file(s) to be analyzed,
runs the cmsRun job, and various plots are produced in the current
directory in muon_resolution.ps. (See the below section on "histogram
dumping" for details about how to get at the histograms, and to run
this code in parallel.)


Zprime2muAsymmetry
------------------

Here there are a few knobs for the user to turn.  Depending on the Z'
model and mass one wishes to study, an appropriate PSet such as the
ones in data/AsymmetryDataSets.cff must be specified.  (For example,
the Zssm1000 PSet contains parameters appropriate for examining a SSM
Z' at 1 TeV.)  Ignoring the more self-explanatory parameters, the user
must specify:

  genSampleFiles: EDM ROOT files with many events from which the code
                  obtains parameterizations for the relevant variables.
  massDistType:   what form the pdf for the invariant mass distribution
                  should take; for example, if the data is Drell-Yan
                  continuum, the user specifies 1 for a falling
                  exponential fit.
  recSigma:       the sigma of the Gaussians used in the smear which
                  simulates detector resolution; these are obtained from
                  the plots on the last two pages of fitHistos.*.ps
                  (which is written by the code).

Then, the dataSet parameter must be changed to the appropriate PSet
name. Other parameters that can be changed are:

  verbosity:       control the level of debug information dumped;
                   current levels are 0-3 (0 being none, and 3 being
                   too much);
  noFit:           only produce histograms of the data, and do not
                   actually perform any fit; useful for getting the
                   plots to obtain the recSigma information above;
  onlyEvalLLR:     if true, do not do the full fit on the data, but
                   evaluate the log-likelihood ratios, useful for spin
                   discrimination studies (currently disabled);
  fitType:         a magic number which determines the form of the
                   cos_theta_cs pdf used in the fit or evaluation of
                   the likelihood ratio;
  numFits:         how many of the fits to do (default is all 6, which
                   are combinations of generated or reconstructed data,
                   and detector resolution simulation via smearing or
                   not);
  maxParamEvents:  a way to cap the number of events read from
                   genSample, useful if using all events is overkill;
  useCachedParams: flag to enable using the cached parameterization that
                   exists in the file specified by the parameter
                   paramCacheFile, instead of re-calculating the
                   parameterization;
  paramCacheFile:  a ROOT filename in which the parameterization
                   calculation will store its quantities;
  calcParamsOnly:  if enabled, the job will only calculate the
                   parameterization and exit;
  onPeak:          whether to use the on-peak fit window or the off-peak
                   one (see the data set parameters in
                   AsymmetryDataSets.cff);
  internalBremOn:  whether bremsstrahlung was turned on for the generated
                   events;
  fixbIn1DFit:     whether to fix b to the "true" value of 1.0 in the
                   simple 1-D fits, so that the only parameter is A_FB
  useCosTrueInFit: whether to cheat and use MC truth for cos(theta) in
                   the full-blown 2-D/6-D fits for diagnostic purposes;
  artificialCosCS: whether to correct the calculated cos_cs values for
                   mistagging using MC truth;
  correctMistags:  whether to bother using the mistagging probability
                   in the fit at all;
  calculateMistag: whether to calculate the mistag probability omega(y,M)
                   on an event-by-event basis rather than using the
                   parameterization omega(y).

Once the config is set, after running the cmsRun job there will be
various files written to the current directory. These contain various
histograms of the data and the result of the fit. (In the filename,
* is replaced by outputFileBase and other important information.)

  diffFrameAsym.*.ps:
    contains plots of cos_theta in various frames (Gottfried-Jackson,
    Collins-Soper, etc.), and plots of A_{FB} as functions of rapidity
    and mass;
  dumpFitData.*.txt:
    a dump of the six variables that are to be fitted: cos_theta_cs,
    dilepton inv. mass, rapidity, pT, phi, and phi_cs, each both
    at generator level and reconstructed;
  fitHistos.*.ps:
    the data in the previous file histogrammed, as well as resolution
    plots relevant to the asymmetry fit;
  fitParams.*.ps:
    histograms of the info used to calculate the parameterizations,
    and mistag probability information plots;
  frameAsym.*.txt:
    A_{FB} in various frames calculated by a simple counting method
    for each reconstruction level;
  recAsymFit.*.txt:
    contains the mistag parameter information and the results of the
    fits (A_{FB} and errors).


Zprime2muMassReach
------------------

The user is supposed to provide three input files.  The first one is
signal (full-interference Z'), the other two are backgrounds.  The
first background sample is the Drell-Yan generated in the same mass
region as the signal, the second one can be anything but is typically
the Drell-Yan generated at lower masses.  The former background sample
is normally used only for signal-vs-background plots (except for
special applications, when it is used to get a parameterization of the
background slope); the latter gets added to the signal sample
(typically provides events leaking from lower masses to higher
masses).

The user should define a number of parameters for each of the sets in
data/MassReachDataSets.cff.  These parameters include the
cross-sections, K factors, number of generated events (used for
normalizations of certain histograms), and lowerGenMass and
upperGenMass vectors (used to pre-select events based on true dimuon
masses to avoid double-counting).  For the full list of sample-related
parameters, see comments in data/MassReachDataSets.cff.

Parameters defining the analysis flow are in data/Zprime2muMassReach.cfi.
Most of them have special purposes and the default values should not
be modified in the "normal" job.  Notable exceptions are:

- FixedMass and FixedFWHM.  They define whether the resonance mass and
  the resonance width are let float in the fits, or are fixed to some
  reasonable values (default).

- ExpPlots.  If this parameter is set to true, invariant mass distributions
  of individual "pseudo-experiments" and the results of their fits
  will be saved into postscript files in test/mass_plots directory
  (for the first 10 pseudo-experiments).

- intLumi.  Defines the integrated luminosity (in inv. fb) for which the
  user wishes to calculate the mass reach.

The code contains several pre-defined parameterizations used in the
fits, such as of the background slope and of the invariant mass
resolution.  The exact values of the parameters depend on several
factors (CMSSW version, alignment scenario, etc.) and hence should be
tuned for every use case.  The values currently used are essentially
the ones used for the studies in the Physics TDR; we made sure they
give reasonable results for the ideal alignment case in CMSSW_1_3_1,
but have not (re-)tuned them carefully.  One caveat: if one wishes to
study Z' masses other than 1 TeV (3 and 5 TeV are the other two
allowed use cases), one needs to change integration limits in
src/Functions.C (mass_min and mass_max in lorengauPlusExpbckgNorm
method).

The output of the job consists of various dumps in Zprime.out, and two
ps files.  Zmodelmass_sig_back.ps contains signal-vs-background plots;
mass_fits.ps stores the results of the fits (notably various
significance distributions), and some goodness-of-fit distributions
for S+B and B-only hypotheses.


Electron extension
------------------

The flow of the code when running in electron mode is nearly identical
to the muon case, except the extra TeV muon collections are
ignored. The HEEPSelector tool written by D.L. Evans is used to pick
"best" electrons. There is a slight difference in the two code paths,
in that the dimuons constructed have the analysis-level cuts applied
to them at all rec levels, while for dielectrons the analysis-level
cuts are only performed on the "best" electrons, since that is the
output of HEEPSelector. So, in electron mode to study what difference
the HEEP selection makes, one can compare the dileptons at GMR to the
dileptons at OPT. To run in electron mode, pass doingElectrons=True to 
the makeZprime2muAnalysisProcess() function in the Python config file.
(See test/testZprime2muResolutionElectrons_cfg.py for an example.)

The HEEPSelector tool in the form was used in 1_6_X does not exist for
2_1, so the electron mode is not yet fully tested for
Zprime2muAnalysis until the HEEP selection is done by default in the
PAT.


Histogram dumping
-----------------

The histograms produced by the code are output in postscript files
by the code itself. This makes it slightly cumbersome to
change the histogram drawing options. To allow easy extraction of the
histograms, we use the TFileService to automatically write histos to
the specified .root file (defined in data/Zprime2muAnalysisCommon.cff,
the default value being "zp2mu_histos.root"). Histograms for
e.g. Zprime2muResolution wind up in a TDirectory of the same name
inside the .root file; see their names in the main code to find the
desired histogram. 

Implementation detail: ROOT automatically deletes the histograms
associated with the file that TFileService creates when the file is
closed, so no explicit delete statements are needed in the code.

Warning: every time you run the code, TFileService will clobber the
.root file specified. Therefore the .root file must be copied out of
the way if it is to be saved.

For Zprime2muResolution, whose output is lots of histograms, this
enables easy parallelization: run Zprime2muResolution jobs with CRAB,
retrieve the zp2mu_histos_X.root files, and hadd to merge them into a
single .root file of histograms.  To get the monolithic postscript
file for the merged collection, re-run one job of Zprime2muResolution
with parameter useHistosFromFile set to true, and with parameter
histoFile set to the filename of the merged .root file. Then the code
will take the histograms from the merged file and draw the postscript,
bypassing the reading of any events in the analyzer.


CMSSW_1_6_12
------------

If you are still doing analysis under 1_6_12 (e.g. if you are using
the CSA07 samples), the version of the code running under 1_6_12 is
still available under the branch "branch16X". No further development
will be done on this branch except to fix major bugs, as management
has declared that no further analyses done with 1_6_X/CSA07 samples
will be approved.


Step-by-step instructions
-------------------------

To check out the package under 2_1_12:

   scramv1 project CMSSW CMSSW_2_1_12
   cd CMSSW_2_1_12/src

   project CMSSW
   cvs co -r V00-03-01 SUSYBSMAnalysis/Zprime2muAnalysis

   # Compile the code, including the extra packages checked out.
   eval `scramv1 runtime -csh`
   scramv1 b

To live on the edge, i.e. to use the HEAD version of the code instead
of the tagged version above, you must also check out and compile some
extra code:

   cvs co -r CMSSW_2_1_12 RecoMuon/MuonIdentification
   cvs co -r HEAD RecoMuon/MuonIdentification/plugins/MuonsFromRefitTracksProducer.cc 
   cvs co -r HEAD RecoMuon/MuonIdentification/python/refitMuons_cfi.py
   scramv1 b

To run:

   cd SUSYBSMAnalysis/Zprime2muAnalysis/test
   cmsRun testZprime2muResolution_cfg.py # or any of the other test/testZprime2mu*_cfg.py

     
